## GROUP BY 처리

ORDER BY 에 이어 GROUP BY 또한 쿼리가 스트리밍된 처리를 할 수 없게하는 처리 중 하나다.

혹여나 HAVING 절을 마치 WHERE 절에 사용된 컬럼에 대해서 인덱스를 추가하는 방식으로 튜닝하는 것 마냥 생각할 수 있는데,

어짜피 HAVING은 인덱스를 사용하지 못하기 때문에, 고민 할 필요가 없다.

GROUP BY 도 ORDER BY 에서 인덱스를 활용한 정렬과 그렇지 못한 정렬 2가지로 나뉘어 지듯,

`인덱스를 활용한 그룹화와 인덱스를 활용하지 않은 그룹화`로 나뉜다.

- 인덱스 활용
    - 인덱스를 그대로 사용하는 GROUP BY 
    - 인덱스를 사용하여 건너뛰는 `루즈 인덱스 스캔`

- 인덱스 활용 못함
    - 임시 테이블 사용


### 인덱스 스캔을 사용하는 GROUP BY

ORDER BY 와 비슷한데,

**GROUP BY 조건에 해당하는 컬럼들이 첫 번째 테이블(조인의 경우 드라이빙 테이블)에 모두 있으면서 순서상 인덱스가 동일한 경우에 사용 가능**하다.

이 경우 인덱스를 차례로 읽으면서 그루핑 작업을 수행한다.

이러한 그루핑 방식을 사용하는 경우에는 실행계획을 봤을 때, `Using index for group-by` 나 정렬을 위한 코멘트가 표시되지 않는다.

<a href="../src/using_index_scan_for_group-by.sql">예시</a>

### 루즈 인덱스 스캔을 사용하는 GROUP BY

<a href="https://github.com/kimhaechang1/book-Real_MySQL/blob/main/docs/ch08-%EC%9D%B8%EB%8D%B1%EC%8A%A4.md#b-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9D%BD%EA%B8%B0">루즈 인덱스 스캔</a> 은 필요한 부분을 읽었으면 건너 뛰는 스캔방식이다.

루즈 인덱스 스캔을 실행계획으로 잡은 경우, `Using index for group-by` 가 보이게 된다.

<a href="">예시</a>

루즈 인덱스 스캔이 사용될지 안될지는 구분하기 어려우나, 

`프리픽스 인덱스`는 루즈 인덱스 스캔을 사용할 수 없다.

```
프리픽스 인덱스(Prefix index)

레코드의 문자열이 너무 길어 리프노드로 저장하기에 노드 사이즈가 너무 큰경우에 사용된다.

용량을 아낄 수 있다는 장점은 있으나, 순서를 명확하게 구분지어야 하는 상황에서는 좋지 않다.

예를들어 테이블에 Apple과 Apple Pie가 있다고 가정하고 인덱스를 앞 5글자만 따오는걸로 가정해보자.

그러면 저 둘 레코드사이에 우열을 가릴 수 없다.
```

<a href="../src/loose_index_scan_example.sql">루즈 인덱스 스캔이 사용되는 경우를 살펴보는 예시</a>

루즈 인덱스 스캔이 사용되지 못하는 경우는 위와는 반대의 경우이다.

- 인덱스 구성의 컬럼 순서와 GROUP BY 에 사용되는 컬럼 순서가 다른 경우

- MIN, MAX 이외의 집계함수 사용 시 

루즈 인덱스 스캔은 그 특성상 `레코드 레인지 스캔` 과 비교가 많이 되는데,

그 이유는 **데이터의 중복성에 따라 유/불리가 결정되기 때문**이다.

왜냐하면 인덱스 레인지 스캔이 효율적인 부분인건, 스킵해야 하는것이 많다는 것을 의미한다.

즉, `조건에 해당하는 전부 읽어 들여 확인해야하는 인덱스 레인지 스캔에 비해 효율`적일 수 밖에 없다.

### 임시테이블을 사용한 GROUP BY 

ORDER BY 때에도 조인의 드라이빙 테이블만으로 정렬이 안되는 경우 최악으로 임시 테이블을 사용한 만큼

GROUP BY 또한 임시 테이블을 사용하여 그루핑을 수행하기도 한다.

임시 테이블을 사용한 GROUP BY 에서는 Extra에 Using temporary 가 보인다.

<a href="../src/using_temporary_for_group-by.sql">예시</a>


## DISTINCT 처리

DISTINCT는 크게 `집계함수와 함께 사용되었을 때`와 `집계함수 없이 단독으로 조회시에 사용되었을 때로 나뉜다.`

- SELECT DISTINCT ...
    - 집계 함수 없이 사용되었을 때에는 주의 할 점으로, 뒤에 나열된 컬럼들의 조합이 유일하면 되는 것이다.
    - 예를들어 "COL1 에 대해서만 중복을 제거하고 싶어" 라고 하여 DISTINCT (COL1), COL2를 하는 경우가 종종 있는데,
    - 실제 SQL 파서에 의해 쓸데없는 괄호는 없어지고 `DISTINCT COL1, COL2` 즉 (COL1, COL2) 조합에 있어서 중복을 제거하게 된다.
    - 그렇기에 `GROUP BY COL1, COL2` 와 내부적으로 같은 작업을 수행한다.

- 집계 함수와 함께 사용
    - `COUNT(DISTINCT COL1)` 이런식으로 사용되는데, 만약 COL1에 대한 인덱스가 드라이빙 테이블 혹은 첫 번째 테이블에 존재한다면 임시 테이블을 사용하지 않는다.
    - `그렇지 않으면 임시테이블을 사용하게 되어있다. 하지만 Extra에 보이진 않는다.`
    - <a href="../src/distinct_with_index.sql">예시</a>