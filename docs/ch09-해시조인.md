## 해시 조인 (hash_join)

기본적으로 조인을 하게되면 `Nested Loop Join` 방식을 사용한다.

그로인해 첫 레코드의 조인 연산 결과가 반환되기까지의 시간은 매우 빠르다.

따라서 웹 서비스와 같은 `온라인 트랜잭션 상황`에서는 `최고의 응답속도`를 필요로하는 시스템에서는 `Nested Loop Join`이 활용된다.

`해시 조인`은 첫 레코드의 조인연산 결과를 받기까지는 느리지만, 마지막 레코드까지의 `전체 수행시간`의 경우 `Nested Loop Join`보다 `빠르다.`

이는 `최고 스루풋`을 중요시 해야 하는 `대용량 데이터 분석 목적`의 전략에 적합하게된다.

MySQL과 같은 서버는 `범용 RDBMS`이며, 범용이라 함은 `온라인 트랜잭션 처리를 위한 데이터베이스`를 말한다.

그 밖의 대용량 데이터 분석의 용도로 MySQL을 보통은 사용하지 않는다.

이는 즉, MySQL의 경우 Nested Loop Join을 사용하되,

조회에서 `조인 조건이 인덱스를 활용할 수 없는 조인`이거나 조인 대상 테이블 중 레코드 건수가 매우 적은경우 해시 조인을 선택한다는 것이다.

해시조인이 속도가 빠르다고 무작정 해시조인으로 옵티마이저에게 힌트를 주어 유도하는것은 좋지 않을수도 있다.

물론 이것도 `MySQL 8.0.19` 까지는 차용책으로 대부분 `Block Nested Loop Join`이 활용되었지만, `MySQL 8.0.20` 부터는 이러한 상황에서 `해시 조인`이 사용된다.

### 해시 조인 작동원리

해시 조인 또한 `조인버퍼`를 사용해서 해싱하고 대상 테이블에서 해싱된 결과에 따라 조인을 수행한다.

해시 조인의 절차에는 크게 `빌드 과정` 과 `프로브 과정`이 있다.

두 테이블중 해싱의 대상이 되는 원본 테이블을 빌드 테이블이라고 지정한다.

지정된 빌드 테이블의 레코드를 가져와서 조인버퍼에서 해싱(클래식 해시 조인 함수)을 진행한다.

여기서 해싱 도중 조인 버퍼의 메모리를 넘어서게 되면, 일정한 청크로 잘라서 각 청크들을 디스크로 저장한다.

이 방식은 마치 MRR의 일부인 블록 네스티드 루프 조인과 비슷하다.

그렇게 해싱이 끝나게 되면 `프로브 과정`으로 넘어가게 되는데, 반대편 테이블이 프로브 테이블이 된다.

프로브 테이블의 레코드들을 읽어오면서 조인을 수행하고, 만약 프로브 레코드들 조차 조인버퍼의 양을 초과화게 된다면

이 역시 일정 청크로 잘라서 순서번호를 매기고 디스크에 저장하게 된다.

앞서서 디스크 스왑이 필요한 상태일 경우 `다음 순서의 빌드 테이블 청크를 들고와서 해싱 테이블을 만들고`(그레이스 해시 조인)

프로브 테이블 청크또한 순서에 맞게 들고와서 조인을 수행한다.

<a href="../src/hash_join_example.sql">예시</a>



