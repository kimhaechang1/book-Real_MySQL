### 쿼리 실행 절차

쿼리가 MySQL 서버에 도착하면 다음과 같은 절차를 가진다.

- SQL 파서를 사용해서 MySQL이 이해할 수 있는 정도로 파싱한다.
    - 주요 행위: 문법 체크
    - 결과물: SQL 파스 트리

- SQL 파스 트리를 기준으로 읽을 테이블을 찾고 어떤 인덱스를 사용해 읽을 지 `옵티마이저`를 통해 결정한다.
    - 주요 행위: 조인이 있는경우 읽을 순서선정, 사용할 인덱스 선정, 임시테이블 사용 여부 등
    - 결과물: `실행 계획`

- 결정된 실행계획을 사용해서 MySQL 엔진이 참여하여 데이터를 가져온다.

### 옵티마이저 종류

- **비용 기반 최적화 (Cost-based Optimizer, CBO)**: 쿼리를 처리하기 위한 다양한 방법을 만들어두고, 각 단위 작업별 비용과 통계 데이터를 기반으로 실행 계획별 비용을 만들어서서 최소가 되는 실행계획을 선택하는 방식

- 규칙 기반 최적화: 내장된 우선순위에 따라 실행 계획을 수립하는 방식, 예전 DBMS에서 사용하는 방식으로 작업별 예상 통계를 만드는것에 대해 CPU 비용이 많이 소모되는것이 부담스러울때 사용되는 방식이었다.

## 풀 테이블 스캔 (Not 풀 인덱스 스캔)

플 테이블 스캔이란 말그대로 테이블내에 모든 레코드를 읽는 방식이다.

다음과 같은 상황에서는 `MySQL 옵티마이저는 풀 테이블 스캔을 선택`한다.

- 테이블의 레코드가 너무 작아서 전부 읽는것이 풀 인덱스 스캔보다 더 빠른 경우

- WHERE 절이나 ON 절에 인덱스를 사용할 수 있는 적절한 조건이 없는경우

- 인덱스 레인지 스캔이라고 하더라도, `레인지 내에 레코드가 너무많아서 풀 테이블 스캔이 효율`적인 경우

여기서 중요한 점은 조건도 조건이지만, 풀 테이블 스캔이 마냥 한페이지씩 포그라운드 스레드가 읽어오는것은 아니다.

물론 조회의 경우 `포 그라운드 스레드가 직접 수행하는것이 일반적이지만`, 풀 테이블 스캔과 같이 `다음의 연속적인 페이지를 읽어와야 하는것`을 인지하면

**리드 어 헤드**라는 기능이 수행되어 `백그라운드 스레드가 미리 버퍼풀에 다음에 읽어와야하는 페이지들을 채워둔다`.

물론 리드 어 헤드 기능은 풀 테이블 스캔에서만 수행되진 않는다.

풀 인덱스 스캔에서도 다음 인덱스가 연속적일 때 마찬가지로 사용될 것이다.

## ORDER BY

### 정렬의 방식과 소트 버퍼

정렬에는 크게 FILE SORT 와 인덱스를 활용한 정렬로 나눠볼 수 있다.

- FILE SORT
    - 별도의 공간에서 정렬 대상 레코드들을 읽어온 후 추가적인 정렬을 수행하는 방식
    - 레코드의 크기에 따라 정렬의 시간이 소요될 수 있다.
    - `EXPLAIN`으로 실행계획 테이블을 봤을 때, `Extra`에 `Using Filesort` 라고 되어있음

- INDEX 정렬
    - 인덱스를 그대로 사용하므로 차례대로 읽으면 정렬이 되어있는 이득을 볼 수 있음
    - 하지만 INSERT, UPDATE, DELETE 에서 테이블 내에 인덱스의 개수 (보통 1.5배) 에 따라 시간이 소요됨

당연하게도 추가 공간을 사용하기에 FILE SORT는 되도록이면 발생하지 않는것이 좋긴하다.

실제로 FILE SORT를 진행하기 위해서 MySQL은 `소트버퍼` 라고 하는 정렬을 위한 추가 공간을 할당받는다.

이러한 `소트버퍼`는 필요한 한계치만큼 할당받고, 바로 반납하게 된다. 

그런데 **소트버퍼 보다 큰 레코드를 정렬해야 하는경우, 멀티머지가 발생한다.**

```
멀티머지 

간단하게 동작원리를 살펴보면

하나의 큰 덩어리째로 소트버퍼에서 정렬할 수 없기 때문에, 소트버퍼에서 정렬할만한 일정 크기 (청크)로 나눈다.

그리고 최소 힙을 사용해서 병합을 진행한다.

각 청크별로 원소가 다음과 같을 때,

청크1: [3, 1, 5]
청크2: [4, 6, 2]
청크3: [0, 8, 7]

각 청크에서 가장 작은 값들을 최소힙에 넣는다
힙 상태: [0, 1, 2]

힙에서 원소를 하나씩 꺼내고, 각 원소가 속해있는 청크에서 다음으로 작은 원소를 넣는다.

이런식으로 청크를 병합하여 정렬하는것을 멀티머지 라고 한다.
```

따라서 디스크 I/O가 발생하기 때문에 속도가 느릴 수 있다. 

그렇다고 `소트버퍼의 한계점을 무작정 늘리면 될까?`

소트버퍼는 반납되는 메모리라곤 했지만, 이는 **공유되는 글로벌 영역이 아닌 세션 영역의 메모리다!**

만약 `커넥션이 늘어나고, 각 커넥션별로 최대 소트버퍼 메모리를 요구하는 트랜잭션이 실행된 경우 운영체제에 의해 OOM 이 발생하여 MySQL 프로세스를 꺼버릴 수도 있다.`

### 싱글패스와 투 패스

정렬의 모드에는 크게 `싱글 패스`와 `투 패스`로 나뉜다.

- 싱글 패스
    - **조회에 필요한 모든 레코드 정보**를 소트 버퍼에 들고와서 기준에 따라 정렬을 수행 한 후 반환하는 방식
    - 대부분의 조회의 경우 싱글패스로 이루어진다.
    - 다만 조회에 필요한 레코드의 크기가 너무 큰 경우 투 패스 모드로 정렬이 수행될 수 있다.

- 투 패스
    - **정렬에 필요한 모든 레코드 정보**를 소트 버퍼에 들고와서 정렬을 수행하고, 각 레코드별로 `조회에 필요한 레코드들을 추가적으로 가져와서 반환`하는 방식
    - 두번 데이터에 접근하는 만큼 비효율적일 수 있다.
    - 하지만 소트버퍼에 들어가는 정보가 `인덱스 정보만 들어가기 때문에, 적은 용량으로 소트버퍼를 운용`할 수 있다.

### 정렬 처리방식

정렬의 처리방식에는 크게 `인덱스를 사용하는 정렬`, `조인에서 드라이빙 테이블만 정렬`, `조인에서 조인 결과를 임시 테이블로 저장한 후 정렬 (임시 테이블 정렬)` 로 나뉜다.

물론 왼쪽으로 갈수록 효율적이며, 오른쪽으로 갈수록 비효율적이다.

- 인덱스를 사용하는 정렬
    - 애초에 인덱스를 사용하여 순서대로 조회하기 때문에 추가적인 정렬이 필요없다.
    - 이를 사용하는 조건으로 다음과 같다.
        - `ORDER BY 절에 사용되는 컬럼`들이 대상 테이블들 중 `첫번째`에 속해있어야 한다.
        - `ORDER BY 절에 사용되는 인덱스들의 순서`가 첫번째 테이블의 `인덱스 순서`와 동일해야 한다.
        - WHERE 절에 `첫 번째 테이블에 사용된 컬럼`이 있다면, 해당 `인덱스가 ORDER BY 에 인덱스와 동일`해야 한다.

    - <a href="../src/using_index_sort.sql">예시</a>
        - 위의 예시에서 `ORDER BY`절은 필요없을 수도 있다.
        - 하지만 있다고해서 옵티마이저가 추가 정렬을 수행하진 않는다.
        - 그렇다고해서 `빼진 말자`, 혹시라도 있을 옵티마이저의 `버그를 생각해야한다.`

- 조인의 드라이빙 테이블만 정렬
    - `드라이빙 테이블을 선정하는 조건`을 먼저 살펴봐야한다.
        - 보통 `left join`과 `right join`이냐에 따라 기준 테이블이 달라지며
        - 또한 기준 테이블의 컬럼만으로도 `where` 나 `on` 절 처리가 가능하거나 효율적이라면 드라이빙 테이블이 된다.
        - 반대는 드라이븐 테이블이 된다.

    - 그래서 `드라이빙 테이블`에 `where 절 조건에 해당하는 레코드를 찾고`
    - 레코드들을 `order by 에 따라 정렬 한 후, 드라이븐 테이블과 조인`을 수행하며
    - `limit`가 있는 경우 해당 조건 만큼 반환한다.
    - <a href="../src/using_driving_table_in_join_condition.sql">예시</a>

- 임시 테이블을 활용한 정렬
    - 원래 조인이 걸린 조회에서 2 테이블 이상이 사용될 때 임시테이블을 사용할 수도 있다.
    - 앞서 조인의 드라이빙 테이블은 그래도 `order by `까지 조건을 봤을 때, 조인의 `드라이빙 테이블로만으로도 충분히 수행가능`하기에 추가 임시 테이블 공간은 필요없었다.
    - 하지만 정렬이 조인을 수행한 후에 수행되어야 하는 경우, 임시 테이블을 사용하게 된다.
    - 이 방식이 안좋은 이유는, `정렬해야할 레코드의 양이 무지막지하게 늘어날 수 있기 때문이다.`
    - 보통 이 실행계획이 잡힌 쿼리의 경우 `Using temporary를 없애는 목표도 쿼리 튜닝에 해당`된다.
    - <a href="../src/using_temporary_table_in_join_condition.sql">예시</a>

### 스트리밍과 버퍼링

`스트리밍 방식`은 조건에 부합하는 레코드를 발견하자마자 `바로 클라이언트에 전송하는 방식`을 의미한다.

그래서 첫 레코드를 받기까지 응답시간이 상당히 빠르다.

- 물론 JDBC와 같은 추가적인 인터페이스와 결합하여 사용하는 경우, 해당 인터페이스 측에서 버퍼링을 해버려서 스트리밍 방식의 이점을 얻지 못할 수 있다.

`버퍼링 방식`은 말그대로 모아서 전송하는 방식으로, 필요한 정렬과 그루핑을 모두 수행하고 나서야 클라이언트로 전송하게 된다.

- 주요 특징으로, 어짜피 정렬 대상 혹은 그루핑 대상을 모두 처리한 후에 `limit `를 적용하기 때문에, `limit`를 활용한 건수줄이기는 MySQL의 작업량을 줄일 순 없다.

앞서 얘기했던 정렬 처리방식에서 `인덱스를 활용한 정렬` 만이 `스트리밍 방식`으로 처리되고, 나머지는 `버퍼링 방식`으로 처리된다.


    


