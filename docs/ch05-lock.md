## 잠금

MySQL의 잠금은 크게 MySQL엔진 레벨의 잠금과 MySQL 스토리지 엔진의 잠금이 있다.

MySQL 엔진은 MySQL 서버내 스토리지 엔진을 제외한 부분을 말하는데, 해당 레벨의 잠금의 경우 모든 스토리지 엔진에 영향을 미친다.

MySQL 엔진 레벨의 잠금은 크게 `글로벌 락`, 테이블 데이터 동기화를 위한 `테이블락`, 테이블 구조에 대한 잠금인 `메타데이터 락`, 

마지막으로 상황에 맞게 사용자가 만들어 사용하는 `네임드 락`이 있다.

### MySQL 엔진레벨 락

- 글로벌 락: 큰 범위로 적용된다. MySQL의 클라이언트 세션들 중 하나라도 해당 락을 획득하면, 나머지 다른 세션에서 SELECT 문을 제외한 DML, DDL을 실행하는경우 락을 해제할 때까지 기다려야 한다.
    - 테이블이나 데이터베이스가 다르더라도 상관없이 기다려야 한다.

    - 해당 락은 백업을 위해 사용하곤 했는데, 나중에 트랜잭션이 적용되는 INNODB 엔진이 나온후 `백업 락`이 추가되면서 백업 도중에도 테이블 내에 읽기 및 데이터 변경이 가능해졌다.

- 네임드 락: `GET_LOCK('문자열')` 을 통해 사용자 임의 락을 만들어 사용한다. 
    - 주로 여러 어플리케이션에서 하나의 데이터베이스에 접근하여 어떤 정보를 동기화 할때 사용되고
    - 배치 프로그램에 의해 하나의 레코드에 복잡한 변경이 발생할 때에도 종종 사용한다.

### InnoDB 엔진 스토리지 레벨 락

InnoDB 엔진에서 사용되는 락은 `레코드 락`, `갭 락`, `넥스트 키 락`, `자동 증가 락`이 있다.

- `레코드 락`: MySQL은 레코드 수준의 락이 가능하다. 하지만 레코드 수준의 락이라는건 진짜 레코드에 거는것이 아니라 해당하는 `인덱스 엔트리`에 락이 걸린다는것을 잊어선 안된다.
    - 따라서 다음의 예제를 실행해보자. <a href="../src/index_with_record_lock.sql">인덱스와 레코드 그리고 락</a>
    - 결론적으로 `first_name`에만 인덱스가 걸려있기 때문에, update 쿼리 실행시에 253개의 레코드에 락이 걸리게 된다.
    - 따라서 적절한 인덱스설정은 곧 레코드 락에도 영향을 미칠 수 있다. 그리고 레코드에 락이 걸리는 것이 아닌, 인덱스 엔트리에 락이 걸린다는것도 알 수 있다.
    - **보조인덱스**를 사용한 변경작업은 `넥스트 키 락` 또는 `갭 락`을 사용하지만, `pk 혹은 unique 의 겨우에는 레코드 락만 작동`한다.

- `갭 락`: MySQL의 특징으로, 레코드와 레코드사이의 인접한 간격에만 락을 거는것을 의미한다. 결국 해당 간격내에 `INSERT`가 발생하지 않도록 한다.
    - 예를들어 범위 쿼리가 BETWEEN 1 AND 5 이면, 1이상 5이하의 범위내에 발생하는 INSERT 쿼리에 대해서는 락을 얻어야 가능하게 된다.

- `넥스트 키 락`: `갭 락` + `레코드 락` 으로서 단일 레코드 뿐만아니라 레코드 사이 간격에도 락을 건다. 

- `자동 증가 락`: `AUTO_INCREMENT`에 대한 락으로, 다음 번호를 얻기위한 그 순간에 락을 걸고 해제한다. 테이블당 하나만 존재하기 때문에 INSERT 가 다수 발생하더라도 서로 기다려야한다.

### 트랜잭션 격리수준

트랜잭션 격리수준이란 것은, 두 트랜잭션에 대해서 얼마나 동일 레코드에 대해 간섭할 수 있는지 정도를 나타낸다.

트랜잭션 격리수준에 따라 팬텀리드, 더티리드, NON-REPEATABLE-READ 가 발생할 수 있다.

- 팬텀리드: 자신의 트랜잭션내에 동일한 조회 쿼리를 실행 할 때마다 레코드가 보여지다가 사라졌다가 하는 경우
- 더티리드: 자신과 다른 트랜잭션에서 커밋되지 못한 쓰기작업이 보여지는 현상
- NON-REPEATABLE-READ: 먼저 실행한 트랜잭션에서 동일한 조회쿼리에 대하여, 반대쪽에서 같은 레코드에 대한 쓰기를 발생시킨경우 동일한 결과를 얻지 못하는 현상

트랜잭션 격리수준은 커밋을 기준으로 커밋되지 않은 정보를 얼마나 보여줄 수 있냐에 따라 다음과 같이 나눌 수 있다.

- `READ_UNCOMMITED`: 커밋되지 않은 INSERT, UPDATE, DELETE 또한 다른 트랜잭션에서 볼 수 있다.
    - 가장 약한 트랜잭션 격리수준으로, 사실상 격리수준이 없는것과 다름없다.
    - 따라서 팬텀리드, 더티리드, NON-REPEATABLE-READ 모두 발생한다.

- `READ_COMMITED`: 커밋된 INSERT, UPDATE, DELETE에 대해서는 다른 트랜잭션에서 읽을 수 있다.
    - 오라클에서 기본세팅된 격리수준이다.
    - 더티리드는 더이상 발견되지 않지만 팬텀리드와 NON-REPEATABLE-READ는 발생한다.

- `REPEATABLE_READ`: 반복가능한 읽기로서, MVCC를 통해 구현되며, `커밋이 발생하더라도 트랜잭션 번호를 통해 순서에 맞는 이전버전을 언두로그로 부터 읽어온다.`
    - MYSQL에서 기본세팅된 격리수준이다.
    - 더티리드는 발생하지 않고, NON-REPEATABLE-READ도 발생하지 않지만, `INNODB엔진이 아니거나 갭 락이 존재하지 않는 DBMS의 경우 팬텀리드가 발생할 수 있다.`
        - MVCC를 구현한 언두로그에서는 COMMIT되지 못한 레코드의 이전내용이 보관되어 있다.
        - 물론 `READ_COMMITED`에서도 MVCC를 구현한 언두로그가 있으며, 이전 내용이 보관되어 있지만, `COMMIT` 이후에는 더이상 언두로그의 내용에서 꺼내오지 않는다.
        - 이러한 INNODB 엔진에서의 `REPEATABLE_READ` 트랜잭션들은 순차적인 번호가 달려있고, 특정 `트랜잭션 번호 구간내에 언두 데이터는 백업되어야 한다.`
        - 물론 MYSQL의 `갭 락`이 있기 때문에, `REPEATABLE_READ`에서도 팬텀리드가 발생하지 않지만 일반적으로 다음의 예시에서는 발생한다.
            - <a href="../src/occur_phantom_read_without_gaplock.sql"> 갭락이 없는 경우에 발생할 수 있는 팬텀리드</a>
            - 분명 MVCC에는 이전값이 함께 있을것이다. 하지만 갭락에 의해 막힌다는 대답보다 먼저 봐야할 것은 잠금 획득과정이다.
            - 잠금 획득에 있어서 언두로그에 있는 12번 레코드에 대해서는 잠금을 걸 수 없다. 그렇다고 잠금을 안걸면 원래 쓰기잠금을 걸어야 하는 입장에서 말이안된다.
            - 따라서 테이블을 기준으로 잠금을 걸게 되는것이고, 그렇기에 `테이블에 데이터를 그대로 조회`할 수 밖에 없다.

- `SERIALIZABLE`: 가장 엄격한 격리수준으로서, 모든 쿼리는 순서대로 실행되어야 한다.


