### MRR (Multi-Range Read Optimization)

MRR은 기본적으로 `Range 스캔에 대해서 Random Access를 줄이기 위해` **검색에 조건이 되는 레코드 값을 버퍼를 사용해서 정렬을 수행 한 후 순차적으로 디스크에 탐색**하는 방식이다.

이 MRR 방식을 응용한 조인 방식중 BKA(Batched Key Access) 조인이 있다.

이는 기본적으론 활성화 되어있진 않다.

## Nested Loop Join 과 Block Nested Loop Join

기본적인 조인 `Nested Loop Join`으로 드라이빙 테이블과 드라이븐 테이블을 선정하고

드라이빙 테이블의 `Where`절 조건에 해당하는 레코드를 읽어와서

`레코드 1건당 드라이븐 테이블 내 풀 테이블 스캔 혹은 풀 인덱스 스캔`으로 조인 조건에 부합하는 레코드를 찾게 된다.

이 과정속에서 수많은 디스크 I/O 가 발생할 수 밖에 없다.

그 이유는 위의 과정에서 **만약 드라이븐 테이블의 조건에 맞는 레코드수가 1000건이라면, 1000건의 드라이븐 테이블 내에 스캔이 이뤄지는것이기 때문이다.**

이러한 경우에서 MySQL에서 `조인 버퍼`를 따로 할당하여 `드라이빙 테이블 내에 조건에 해당하는 데이터를 메모리위에 올려둔다.`

그리고 `드라이븐 테이블을 풀 인덱스 스캔 혹은 풀 테이블 스캔을 하면서 조인 조건에 맞는 모든 레코드들을 찾게`된다.

이러한 방식을 통해 일정 조인 버퍼 크기에 비례하여 DISK I/O 횟수를 효율적으로 관리할 수 있다.

이것을 `Block Nested Loop Join` 방식이라고 한다.

위의 방식을 살펴보면 드라이븐 테이블을 기준으로 조인버퍼에 있는 드라이빙 테이블 레코드를 찾는것으로

드라이빙과 드라이븐간에 역전이 되는것 처럼 실행된다.

따라서 `조인 버퍼가 사용되는 조인에서는 정렬순서가 보장되지 못할수 있다.`

Join Buffer를 활용한 위의 방식을 사용하는 경우는 다음과 같다.

- 테이블간의 조인의 조건이 명확하지 않아 카테시안 곱이 발생하여 조인 연산의 결과가 너무많을 때
    - <a href="../src/using_join_buffer_with_cartesian_product.md">예시</a>

- 인덱스를 활용할 수 없을 때

물론 8.0.18 버전 이후로 부터는 더이상 `Block Nested Loop`가 사용되지 않고 `hash join 이 사용된다.`



